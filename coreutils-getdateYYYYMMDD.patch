diff -urNp coreutils-6.9.orig/lib/getdate.y coreutils-6.9/lib/getdate.y
--- coreutils-6.9.orig/lib/getdate.y	2007-02-23 19:25:21.000000000 +0100
+++ coreutils-6.9/lib/getdate.y	2007-11-23 10:27:13.000000000 +0100
@@ -199,6 +199,42 @@ static int yylex (union YYSTYPE *, parse
 static int yyerror (parser_control const *, char const *);
 static long int time_zone_hhmm (textint, long int);
 
+static void
+digits_to_date_time (parser_control *pc, textint text_int)
+{
+	if (pc->dates_seen && ! pc->year.digits
+	    && ! pc->rels_seen && (pc->times_seen || 2 < text_int.digits))
+	  pc->year = text_int;
+	else
+	  {
+	    if (4 < text_int.digits)
+	      {
+		pc->dates_seen++;
+		pc->day = text_int.value % 100;
+		pc->month = (text_int.value / 100) % 100;
+		pc->year.value = text_int.value / 10000;
+		pc->year.digits = text_int.digits - 4;
+	      }
+	    else
+	      {
+		pc->times_seen++;
+		if (text_int.digits <= 2)
+		  {
+		    pc->hour = text_int.value;
+		    pc->minutes = 0;
+		  }
+		else
+		  {
+		    pc->hour = text_int.value / 100;
+		    pc->minutes = text_int.value % 100;
+		  }
+		pc->seconds.tv_sec = 0;
+		pc->seconds.tv_nsec = 0;
+		pc->meridian = MER24;
+	      }
+	  }
+}
+
 %}
 
 /* We want a reentrant parser, even if the TZ manipulation and the calls to
@@ -268,6 +304,7 @@ item:
   | rel
       { pc->rels_seen = true; }
   | number
+  | hybrid
   ;
 
 time:
@@ -543,38 +580,23 @@ unsigned_seconds:
 
 number:
     tUNUMBER
+      { digits_to_date_time (pc, $1); }
+  ;
+
+hybrid:
+    tUNUMBER relunit_snumber
       {
-	if (pc->dates_seen && ! pc->year.digits
-	    && ! pc->rels_seen && (pc->times_seen || 2 < $1.digits))
-	  pc->year = $1;
-	else
-	  {
-	    if (4 < $1.digits)
-	      {
-		pc->dates_seen++;
-		pc->day = $1.value % 100;
-		pc->month = ($1.value / 100) % 100;
-		pc->year.value = $1.value / 10000;
-		pc->year.digits = $1.digits - 4;
-	      }
-	    else
-	      {
-		pc->times_seen++;
-		if ($1.digits <= 2)
-		  {
-		    pc->hour = $1.value;
-		    pc->minutes = 0;
-		  }
-		else
-		  {
-		    pc->hour = $1.value / 100;
-		    pc->minutes = $1.value % 100;
-		  }
-		pc->seconds.tv_sec = 0;
-		pc->seconds.tv_nsec = 0;
-		pc->meridian = MER24;
-	      }
-	  }
+	/* Hybrid all-digit and relative offset, so that we accept e.g.,
+	   "YYYYMMDD +N days" as well as "YYYYMMDD N days".  */
+	digits_to_date_time (pc, $1);
+	pc->rel.ns += $2.ns;
+	pc->rel.seconds += $2.seconds;
+	pc->rel.minutes += $2.minutes;
+	pc->rel.hour += $2.hour;
+	pc->rel.day += $2.day;
+	pc->rel.month += $2.month;
+	pc->rel.year += $2.year;
+	pc->rels_seen = true;
       }
   ;
 
diff -urNp coreutils-6.9.orig/tests/misc/date coreutils-6.9/tests/misc/date
--- coreutils-6.9.orig/tests/misc/date	2007-03-18 22:36:43.000000000 +0100
+++ coreutils-6.9/tests/misc/date	2007-11-23 10:14:19.000000000 +0100
@@ -135,6 +135,11 @@ my @Tests =
      ['next-mo', "-d '$d1 next month' '+%Y-%m-%d %T'", {OUT=>"$dm $t0"}],
      ['next-y', "-d '$d1 next year'   '+%Y-%m-%d %T'", {OUT=>"$dy $t0"}],
 
+     # This has always worked, ...
+     ['rel-1',  "-d '20050101  1 day'  +%F", {OUT=>"2005-01-02"}],
+     # ...but up to coreutils-6.9, this was rejected due to the "+".
+     ['rel-1p', "-d '20050101 +1 day'  +%F", {OUT=>"2005-01-02"}],
+
      ['utc-0', "-u -d '08/01/97 6:00' '+%D,%H:%M'", {OUT=>"08/01/97,06:00"},
 	       {ENV => 'TZ=UTC+4'}],
 
