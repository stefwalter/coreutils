diff -urNp coreutils-6.12-orig/lib/getdate.y coreutils-6.12/lib/getdate.y
--- coreutils-6.12-orig/lib/getdate.y	2008-01-31 19:37:19.000000000 +0100
+++ coreutils-6.12/lib/getdate.y	2008-10-08 15:49:35.000000000 +0200
@@ -1,8 +1,8 @@
 %{
 /* Parse a string into an internal time stamp.
 
-   Copyright (C) 1999, 2000, 2002, 2003, 2004, 2005, 2006, 2007 Free Software
-   Foundation, Inc.
+   Copyright (C) 1999, 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008
+   Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -60,7 +60,7 @@
 # undef static
 #endif
 
-#include <ctype.h>
+#include <c-ctype.h>
 #include <limits.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -205,7 +205,7 @@ typedef struct
 union YYSTYPE;
 static int yylex (union YYSTYPE *, parser_control *);
 static int yyerror (parser_control const *, char const *);
-static long int time_zone_hhmm (textint, long int);
+static long int time_zone_hhmm (parser_control *, textint, long int);
 
 /* Extract into *PC any date and time info from a string of digits
    of the form e.g., YYYYMMDD, YYMMDD, HHMM, HH (and sometimes YYY,
@@ -246,6 +246,31 @@ digits_to_date_time (parser_control *pc,
     }
 }
 
+/* Increment PC->rel by FACTOR * REL (FACTOR is 1 or -1).  */
+static void
+apply_relative_time (parser_control *pc, relative_time rel, int factor)
+{
+  pc->rel.ns += factor * rel.ns;
+  pc->rel.seconds += factor * rel.seconds;
+  pc->rel.minutes += factor * rel.minutes;
+  pc->rel.hour += factor * rel.hour;
+  pc->rel.day += factor * rel.day;
+  pc->rel.month += factor * rel.month;
+  pc->rel.year += factor * rel.year;
+  pc->rels_seen = true;
+}
+
+/* Set PC-> hour, minutes, seconds and nanoseconds members from arguments.  */
+static void
+set_hhmmss (parser_control *pc, long int hour, long int minutes,
+	    time_t sec, long int nsec)
+{
+  pc->hour = hour;
+  pc->minutes = minutes;
+  pc->seconds.tv_sec = sec;
+  pc->seconds.tv_nsec = nsec;
+}
+
 %}
 
 /* We want a reentrant parser, even if the TZ manipulation and the calls to
@@ -268,7 +293,7 @@ digits_to_date_time (parser_control *pc,
 %token tAGO tDST
 
 %token tYEAR_UNIT tMONTH_UNIT tHOUR_UNIT tMINUTE_UNIT tSEC_UNIT
-%token <intval> tDAY_UNIT
+%token <intval> tDAY_UNIT tDAY_SHIFT
 
 %token <intval> tDAY tDAYZONE tLOCAL_ZONE tMERIDIAN
 %token <intval> tMONTH tORDINAL tZONE
@@ -279,7 +304,7 @@ digits_to_date_time (parser_control *pc,
 %type <intval> o_colon_minutes o_merid
 %type <timespec> seconds signed_seconds unsigned_seconds
 
-%type <rel> relunit relunit_snumber
+%type <rel> relunit relunit_snumber dayshift
 
 %%
 
@@ -313,7 +338,6 @@ item:
   | day
       { pc->days_seen++; }
   | rel
-      { pc->rels_seen = true; }
   | number
   | hybrid
   ;
@@ -321,45 +345,32 @@ item:
 time:
     tUNUMBER tMERIDIAN
       {
-	pc->hour = $1.value;
-	pc->minutes = 0;
-	pc->seconds.tv_sec = 0;
-	pc->seconds.tv_nsec = 0;
+	set_hhmmss (pc, $1.value, 0, 0, 0);
 	pc->meridian = $2;
       }
   | tUNUMBER ':' tUNUMBER o_merid
       {
-	pc->hour = $1.value;
-	pc->minutes = $3.value;
-	pc->seconds.tv_sec = 0;
-	pc->seconds.tv_nsec = 0;
+	set_hhmmss (pc, $1.value, $3.value, 0, 0);
 	pc->meridian = $4;
       }
   | tUNUMBER ':' tUNUMBER tSNUMBER o_colon_minutes
       {
-	pc->hour = $1.value;
-	pc->minutes = $3.value;
-	pc->seconds.tv_sec = 0;
-	pc->seconds.tv_nsec = 0;
+	set_hhmmss (pc, $1.value, $3.value, 0, 0);
 	pc->meridian = MER24;
 	pc->zones_seen++;
-	pc->time_zone = time_zone_hhmm ($4, $5);
+	pc->time_zone = time_zone_hhmm (pc, $4, $5);
       }
   | tUNUMBER ':' tUNUMBER ':' unsigned_seconds o_merid
       {
-	pc->hour = $1.value;
-	pc->minutes = $3.value;
-	pc->seconds = $5;
+	set_hhmmss (pc, $1.value, $3.value, $5.tv_sec, $5.tv_nsec);
 	pc->meridian = $6;
       }
   | tUNUMBER ':' tUNUMBER ':' unsigned_seconds tSNUMBER o_colon_minutes
       {
-	pc->hour = $1.value;
-	pc->minutes = $3.value;
-	pc->seconds = $5;
+	set_hhmmss (pc, $1.value, $3.value, $5.tv_sec, $5.tv_nsec);
 	pc->meridian = MER24;
 	pc->zones_seen++;
-	pc->time_zone = time_zone_hhmm ($6, $7);
+	pc->time_zone = time_zone_hhmm (pc, $6, $7);
       }
   ;
 
@@ -381,16 +392,9 @@ zone:
       { pc->time_zone = $1; }
   | tZONE relunit_snumber
       { pc->time_zone = $1;
-	pc->rel.ns += $2.ns;
-	pc->rel.seconds += $2.seconds;
-	pc->rel.minutes += $2.minutes;
-	pc->rel.hour += $2.hour;
-	pc->rel.day += $2.day;
-	pc->rel.month += $2.month;
-	pc->rel.year += $2.year;
-        pc->rels_seen = true; }
+	apply_relative_time (pc, $2, 1); }
   | tZONE tSNUMBER o_colon_minutes
-      { pc->time_zone = $1 + time_zone_hhmm ($2, $3); }
+      { pc->time_zone = $1 + time_zone_hhmm (pc, $2, $3); }
   | tDAYZONE
       { pc->time_zone = $1 + 60; }
   | tZONE tDST
@@ -495,25 +499,11 @@ date:
 
 rel:
     relunit tAGO
-      {
-	pc->rel.ns -= $1.ns;
-	pc->rel.seconds -= $1.seconds;
-	pc->rel.minutes -= $1.minutes;
-	pc->rel.hour -= $1.hour;
-	pc->rel.day -= $1.day;
-	pc->rel.month -= $1.month;
-	pc->rel.year -= $1.year;
-      }
+      { apply_relative_time (pc, $1, -1); }
   | relunit
-      {
-	pc->rel.ns += $1.ns;
-	pc->rel.seconds += $1.seconds;
-	pc->rel.minutes += $1.minutes;
-	pc->rel.hour += $1.hour;
-	pc->rel.day += $1.day;
-	pc->rel.month += $1.month;
-	pc->rel.year += $1.year;
-      }
+      { apply_relative_time (pc, $1, 1); }
+  | dayshift
+      { apply_relative_time (pc, $1, 1); }
   ;
 
 relunit:
@@ -575,6 +565,11 @@ relunit_snumber:
       { $$ = RELATIVE_TIME_0; $$.seconds = $1.value; }
   ;
 
+dayshift:
+    tDAY_SHIFT
+      { $$ = RELATIVE_TIME_0; $$.day = $1; }
+  ;
+
 seconds: signed_seconds | unsigned_seconds;
 
 signed_seconds:
@@ -600,14 +595,7 @@ hybrid:
 	/* Hybrid all-digit and relative offset, so that we accept e.g.,
 	   "YYYYMMDD +N days" as well as "YYYYMMDD N days".  */
 	digits_to_date_time (pc, $1);
-	pc->rel.ns += $2.ns;
-	pc->rel.seconds += $2.seconds;
-	pc->rel.minutes += $2.minutes;
-	pc->rel.hour += $2.hour;
-	pc->rel.day += $2.day;
-	pc->rel.month += $2.month;
-	pc->rel.year += $2.year;
-	pc->rels_seen = true;
+	apply_relative_time (pc, $2, 1);
       }
   ;
 
@@ -688,10 +676,10 @@ static table const time_units_table[] =
 /* Assorted relative-time words. */
 static table const relative_time_table[] =
 {
-  { "TOMORROW",	tDAY_UNIT,	 1 },
-  { "YESTERDAY",tDAY_UNIT,	-1 },
-  { "TODAY",	tDAY_UNIT,	 0 },
-  { "NOW",	tDAY_UNIT,	 0 },
+  { "TOMORROW",	tDAY_SHIFT,	 1 },
+  { "YESTERDAY",tDAY_SHIFT,	-1 },
+  { "TODAY",	tDAY_SHIFT,	 0 },
+  { "NOW",	tDAY_SHIFT,	 0 },
   { "LAST",	tORDINAL,	-1 },
   { "THIS",	tORDINAL,	 0 },
   { "NEXT",	tORDINAL,	 1 },
@@ -814,15 +802,33 @@ static table const military_table[] =
 
 /* Convert a time zone expressed as HH:MM into an integer count of
    minutes.  If MM is negative, then S is of the form HHMM and needs
-   to be picked apart; otherwise, S is of the form HH.  */
+   to be picked apart; otherwise, S is of the form HH.  As specified in
+   http://www.opengroup.org/susv3xbd/xbd_chap08.html#tag_08_03, allow
+   only valid TZ range, and consider first two digits as hours, if no
+   minutes specified.  */
 
 static long int
-time_zone_hhmm (textint s, long int mm)
+time_zone_hhmm (parser_control *pc, textint s, long int mm)
 {
+  long int n_minutes;
+
+  /* If the length of S is 1 or 2 and no minutes are specified,
+     interpret it as a number of hours.  */
+  if (s.digits <= 2 && mm < 0)
+    s.value *= 100;
+
   if (mm < 0)
-    return (s.value / 100) * 60 + s.value % 100;
+    n_minutes = (s.value / 100) * 60 + s.value % 100;
   else
-    return s.value * 60 + (s.negative ? -mm : mm);
+    n_minutes = s.value * 60 + (s.negative ? -mm : mm);
+
+  /* If the absolute number of minutes is larger than 24 hours,
+     arrange to reject it by incrementing pc->zones_seen.  Thus,
+     we allow only values in the range UTC-24:00 to UTC+24:00.  */
+  if (24 * 60 < abs (n_minutes))
+    pc->zones_seen++;
+
+  return n_minutes;
 }
 
 static int
@@ -919,7 +925,7 @@ lookup_word (parser_control const *pc, c
   for (p = word; *p; p++)
     {
       unsigned char ch = *p;
-      *p = toupper (ch);
+      *p = c_toupper (ch);
     }
 
   for (tp = meridian_table; tp->name; tp++)
@@ -984,7 +990,7 @@ yylex (YYSTYPE *lvalp, parser_control *p
 
   for (;;)
     {
-      while (c = *pc->input, isspace (c))
+      while (c = *pc->input, c_isspace (c))
 	pc->input++;
 
       if (ISDIGIT (c) || c == '-' || c == '+')
@@ -995,7 +1001,7 @@ yylex (YYSTYPE *lvalp, parser_control *p
 	  if (c == '-' || c == '+')
 	    {
 	      sign = c == '-' ? -1 : 1;
-	      while (c = *++pc->input, isspace (c))
+	      while (c = *++pc->input, c_isspace (c))
 		continue;
 	      if (! ISDIGIT (c))
 		/* skip the '-' sign */
@@ -1099,7 +1105,7 @@ yylex (YYSTYPE *lvalp, parser_control *p
 	    }
 	}
 
-      if (isalpha (c))
+      if (c_isalpha (c))
 	{
 	  char buff[20];
 	  char *p = buff;
@@ -1111,7 +1117,7 @@ yylex (YYSTYPE *lvalp, parser_control *p
 		*p++ = c;
 	      c = *++pc->input;
 	    }
-	  while (isalpha (c) || c == '.');
+	  while (c_isalpha (c) || c == '.');
 
 	  *p = '\0';
 	  tp = lookup_word (pc, buff);
@@ -1224,7 +1230,7 @@ get_date (struct timespec *result, char 
   if (! tmp)
     return false;
 
-  while (c = *p, isspace (c))
+  while (c = *p, c_isspace (c))
     p++;
 
   if (strncmp (p, "TZ=\"", 4) == 0)
@@ -1436,25 +1442,6 @@ get_date (struct timespec *result, char 
 	    goto fail;
 	}
 
-      if (pc.zones_seen)
-	{
-	  long int delta = pc.time_zone * 60;
-	  time_t t1;
-#ifdef HAVE_TM_GMTOFF
-	  delta -= tm.tm_gmtoff;
-#else
-	  time_t t = Start;
-	  struct tm const *gmt = gmtime (&t);
-	  if (! gmt)
-	    goto fail;
-	  delta -= tm_diff (&tm, gmt);
-#endif
-	  t1 = Start - delta;
-	  if ((Start < t1) != (delta < 0))
-	    goto fail;	/* time_t overflow */
-	  Start = t1;
-	}
-
       /* Add relative date.  */
       if (pc.rel.year | pc.rel.month | pc.rel.day)
 	{
@@ -1477,6 +1464,27 @@ get_date (struct timespec *result, char 
 	    goto fail;
 	}
 
+      /* The only "output" of this if-block is an updated Start value,
+	 so this block must follow others that clobber Start.  */
+      if (pc.zones_seen)
+	{
+	  long int delta = pc.time_zone * 60;
+	  time_t t1;
+#ifdef HAVE_TM_GMTOFF
+	  delta -= tm.tm_gmtoff;
+#else
+	  time_t t = Start;
+	  struct tm const *gmt = gmtime (&t);
+	  if (! gmt)
+	    goto fail;
+	  delta -= tm_diff (&tm, gmt);
+#endif
+	  t1 = Start - delta;
+	  if ((Start < t1) != (delta < 0))
+	    goto fail;	/* time_t overflow */
+	  Start = t1;
+	}
+
       /* Add relative hours, minutes, and seconds.  On hosts that support
 	 leap seconds, ignore the possibility of leap seconds; e.g.,
 	 "+ 10 minutes" adds 600 seconds, even if one of them is a
